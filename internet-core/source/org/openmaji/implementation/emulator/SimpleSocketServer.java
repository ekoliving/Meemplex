/*
 * Copyright 2005 by Majitek Limited.  All Rights Reserved.
 *
 * This software is the proprietary information of Majitek Limited.
 * Use is subject to license terms.
 */

package org.openmaji.implementation.emulator;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;
import java.util.Vector;
import java.util.logging.Logger;

/**
 * This Runnable helper class is used when emulating a simple telnet-like
 * server that can only manage a single connection at a time. Telnet servers
 * allow multiple clients to connect at the same time but some simple hardware
 * devices do not: this class was written for that particular class of devices.
 *
 * @author Chris Kakris
 */
public class SimpleSocketServer implements Runnable
{
  private static final int READ_BUFFER_SIZE = 256;
  private static final Logger logger = Logger.getAnonymousLogger();

  private final int port;
  private final MessageHandler messageHandler;
  private volatile boolean runThread = true;
  private ServerSocketChannel serverSocketChannel;
  private volatile Selector selector;
  private SelectionKey connectedSocketSelectionKey;
  private volatile boolean haveActiveConnection = false;
  private Vector<String> outgoingMessages = new Vector<String>();
  private char lineTerminator = '\n';
  private StringBuffer buffer = new StringBuffer();

  /**
   * Creates an instance which listens on the specified port for incoming
   * connections and uses the provided message handler to process each message.
   * 
   * @param port  The port the emulator listens on for a connection
   * @param messageHandler  The message handler used to process incoming messages
   * @param lineTerminator  Character used as line terminator for incoming messages
   */
  public SimpleSocketServer(int port, MessageHandler messageHandler, char lineTerminator) throws IOException
  {
    this.port = port;
    this.messageHandler = messageHandler;
    this.lineTerminator = lineTerminator;
  }

  /**
   * Send a message to the currently connected client. If there is no client
   * currently connected then the message is simply ignored.
   * 
   * @param message The message to send to the client
   */
  public void sendMessage(String message)
  {
    if ( haveActiveConnection )
    {
      outgoingMessages.add(message);
      connectedSocketSelectionKey.interestOps(SelectionKey.OP_READ|SelectionKey.OP_WRITE);
      selector.wakeup();
    }
  }

  /**
   * This method listens for incoming socket connections and once one is
   * established it passes all incoming messages to the MessageHandler
   * specified in the constructor. Responses generated by the MessageHandler
   * are written back to the socket.
   */
  public void run()
  {
    try
    {
      serverSocketChannel = ServerSocketChannel.open();
      ServerSocket serverSocket = serverSocketChannel.socket();
      serverSocket.bind(new InetSocketAddress(port));
      serverSocketChannel.configureBlocking(false);
      selector = Selector.open();
      serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);
      handleSelectorEvents();
      Set<SelectionKey> keys = selector.keys();
      for ( Iterator<SelectionKey> iterator = keys.iterator(); iterator.hasNext(); )
      {
        SelectionKey key = iterator.next();
        key.channel().close();
      }
      selector.close();
    }
    catch ( IOException ex )
    {
    	logger.info("Giving up, thread terminating because of: "+ex.getMessage());
    }
  }
  
  private void handleSelectorEvents() throws IOException
  {
    while ( runThread )
    {
      selector.select();
      Set<SelectionKey> readyKeys = selector.selectedKeys();
      Iterator<SelectionKey> iterator = readyKeys.iterator();
      while ( iterator.hasNext() )
      {
        SelectionKey key = iterator.next();
        iterator.remove();
        try
        {
          if ( key.isAcceptable() )
          {
            acceptConnection(key);
          }
          else if ( key.isReadable() )
          {
            readMessage(key);
          }
          else if ( key.isWritable() )
          {
            writeOutstandingMessages(key);
          }
        }
        catch ( IOException ex )
        {
          haveActiveConnection = false;
          key.cancel();
          try { key.channel().close(); } catch ( IOException cex ) { /* Ignore */ }
          logger.info("Connection closed due to: "+ex.getMessage());
        }
      }
    }
  }

  private void acceptConnection(SelectionKey key) throws IOException
  {
    ServerSocketChannel server = (ServerSocketChannel) key.channel();
    if ( haveActiveConnection )
    {
    	logger.info("Only one connection at a time");
      SocketChannel socketChannel = server.accept();
      socketChannel.close();
    }
    else
    {
      SocketChannel socketChannel = server.accept();
      logger.info("Accepted connection from " + socketChannel.socket().getRemoteSocketAddress());
      socketChannel.configureBlocking(false);
      connectedSocketSelectionKey = socketChannel.register(selector,SelectionKey.OP_READ);
      ByteBuffer buffer = ByteBuffer.allocate(READ_BUFFER_SIZE);
      connectedSocketSelectionKey.attach(buffer);
      haveActiveConnection = true;
    }
  }

  private void readMessage(SelectionKey key) throws IOException
  {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    ByteBuffer output = (ByteBuffer) key.attachment();
    output.clear();

    int bytesRead = socketChannel.read(output);
    if ( bytesRead == -1 )
    {
      key.cancel();
      key.channel().close();
      haveActiveConnection = false;
      logger.info("Connection closed");
      return;
    }

    if ( bytesRead > 0 )
    {
      output.flip();
      while ( output.hasRemaining() )
      {
        byte oneByte = output.get();
        if ( oneByte == lineTerminator )
        {
          if ( buffer.length() > 0 )
          {
            String message = buffer.toString();
            String response = messageHandler.handleMessage(message);
            if ( response != null )
            {
              sendMessage(response);
            }
            buffer = new StringBuffer();
          }
        }
        else
        {
          buffer.append((char) oneByte);
        }
      }
    }
  }

  private void writeOutstandingMessages(SelectionKey key) throws IOException
  {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    
    while ( ! outgoingMessages.isEmpty() )
    {
      String message = (String) outgoingMessages.remove(0);
      ByteBuffer byteBuffer = ByteBuffer.wrap(message.getBytes());
//      byteBuffer.flip();
      socketChannel.write(byteBuffer);
    }

    connectedSocketSelectionKey.interestOps(SelectionKey.OP_READ);
  }

  /**
   * Signals this thread to stop processing messages, close the existing
   * socket and terminate.
   */
  public void shutdown()
  {
    runThread = false;
    if ( selector != null )
    {
      selector.wakeup();
    }
  }

  public static void main(String[] args) throws IOException
  {
    for ( int loop = 0; loop < 5; loop++ )
    {
      SimpleSocketServer server = new SimpleSocketServer(5201,null,'\n');
      Thread serverThread = new Thread(server);
      serverThread.setDaemon(true);
      System.out.println("starting thread");
      serverThread.start();
      for ( int i = 0; i < 4; i++ )
      {
        try { Thread.sleep(2000); } catch ( InterruptedException ex ) { /* Ignore */ }
        server.sendMessage("Hello\n");
      }
      System.out.println("stopping thread");
      server.shutdown();
      System.out.println("thread stopped");
      try { Thread.sleep(2000); } catch ( InterruptedException ex ) { /* Ignore */ }
    }
  }
}