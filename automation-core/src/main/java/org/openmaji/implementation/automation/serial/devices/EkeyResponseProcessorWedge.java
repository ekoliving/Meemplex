/*
 * Copyright 2006 by EkoLiving Pty Ltd.  All Rights Reserved.
 *
 * This software is the proprietary information of EkoLiving Pty Ltd.
 * Use is subject to license terms.
 */

package org.openmaji.implementation.automation.serial.devices;

import org.openmaji.meem.Wedge;
import org.openmaji.meem.definition.WedgeDefinition;
import org.openmaji.meem.definition.WedgeDefinitionFactory;
import org.openmaji.meem.definition.WedgeDefinitionProvider;
import org.openmaji.meem.definition.WedgeDefinitionUtility;
import org.openmaji.meem.wedge.configuration.ConfigurationClient;
import org.openmaji.meem.wedge.configuration.ConfigurationClientAdapter;
import org.openmaji.meem.wedge.configuration.ConfigurationSpecification;
import org.openmaji.meem.wedge.lifecycle.LifeCycleClient;
import org.openmaji.meem.wedge.lifecycle.LifeCycleClientAdapter;
import org.openmaji.meem.wedge.lifecycle.LifeCycleState;
import org.openmaji.system.manager.thread.ThreadManager;

import org.openmaji.automation.address.SimpleAddress;
import org.openmaji.automation.controller.DeviceHealthStateClient;
import org.openmaji.automation.device.DeviceHealth;
import org.openmaji.automation.device.SimpleDeviceHealth;
import org.openmaji.automation.util.HexHelper;
import org.openmaji.common.Binary;
import org.openmaji.common.Value;
import org.openmaji.common.Variable;
import org.openmaji.diagnostic.Debug;



import java.util.logging.Level;
import java.util.logging.Logger;


/**
 * The EkeyResponseProcessorWedge is responsible for processing the events
 * generated by the Ekey unit's serial port.
 *
 * @author  Christos Kakris
 */

public class EkeyResponseProcessorWedge implements Variable, Wedge, WedgeDefinitionProvider
{
  private static Logger logger = Logger.getAnonymousLogger();
  private static final int DEBUG_HEARTBEATS = 1;
  private static final int DEBUG_NULLS = 2;
  private static final int DEBUG_SUCCESS = 4;
  private static final int DEBUG_FAILURE = 8;

  public DeviceHealthStateClient deviceHealthStateOutput;
  public Binary binaryOutput;

  public ConfigurationClient configurationClientConduit = new ConfigurationClientAdapter(this);
  public LifeCycleClient lifeCycleClientConduit = new LifeCycleClientAdapter(this);
  public ThreadManager threadManagerConduit;
  public Debug debugConduit = new MyDebugConduit();

  public int emulator;
  public transient ConfigurationSpecification emulatorSpecification = ConfigurationSpecification.create("Start emulator, 1=yes 0=no",Integer.class,LifeCycleState.LOADED);
  public int demoMode;
  public transient ConfigurationSpecification demoModeSpecification = ConfigurationSpecification.create("Demo mode, 1=yes 0=no",Integer.class,LifeCycleState.LOADED);

  private Thread emulatorThread;
  private volatile boolean stopRunning;
  private int debugLevel;

  /* ----------------- Variable interface ----------------------------------- */

  public void valueChanged(Value value)
  {
    if ( value == null) return;
    
    try
    {
      doValueChanged(value.toString());
    }
    catch ( Exception ex )
    {
      logger.log(Level.WARNING, "valueChanged() - "+ex.getMessage());
    }
  }

  /* ----------------- WedgeDefinitionProvider interface -------------------- */

  public WedgeDefinition getWedgeDefinition()
  {
    WedgeDefinition wedgeDefinition = WedgeDefinitionFactory.spi.create().inspectWedgeDefinition(this.getClass());
    WedgeDefinitionUtility.renameFacetIdentifier(wedgeDefinition,"variable","variableInput");
    return wedgeDefinition;
  }

  /* ---------------- configuration ----------------------------------------- */

  public void setEmulator(Integer value)
  {
    emulator = value.intValue();
  }

  public void setDemoMode(Integer value)
  {
    demoMode = value.intValue();
  }

  /* -------------------- lifecycle methods --------------------------------- */

  public void commence()
  {
    if ( emulator == 1 )
    {
      stopRunning = false;
      emulatorThread = new EmulatorThread();
      threadManagerConduit.queue(emulatorThread, System.currentTimeMillis() + 3000);
    }
  }

  public void conclude()
  {
    stopRunning = true;
    emulatorThread = null;
  }

  /* ---------------- private methods --------------------------------------- */

  /*
      The Ekey serial port generates a heart beat, a failure message or
      a success message.
      
      The heart is two bytes long and can be one of the following:
        0x31 0x4a
        0x30 0x4a
        0x30 0x00
        0x00 0x00

      The failure message is a single zero byte:
        0x00
      
      The success message is 10 bytes in length but is sometimes wrapped
      onto the second line.
   */
  private void doValueChanged(String response) throws Exception
  {
    if ( response == null || response.length() == 0 )
    {
      debug(DEBUG_NULLS,response);
      return;  // ignore this null message
    }

    if ( response.length() == 2 )
    {
      // Most probably a heartbeat
      debug(DEBUG_HEARTBEATS,response);
      char byte1 = response.charAt(0);
      char byte2 = response.charAt(1);
      if ( byte1 == 0x31 && byte2 == 0x4a )
      {
        return;
      }
      if ( byte1 == 0x00 && byte2 == 0x00 )
      {
        return;
      }
      if ( byte1 == 0x30 && ( byte2 == 0x4a || byte2 == 0x00 ) )
      {
        return;
      }
      // If we get here then it's an unrecognised message type. Log it and return
      logger.log(Level.WARNING, "Unrecognised message ["+response+"]");
      return;
    }

    SimpleAddress address = new SimpleAddress("Ekey");
    DeviceHealth health = new SimpleDeviceHealth(DeviceHealth.USEFUL);
    EkeyDeviceState state = new EkeyDeviceState(true);

    if ( response.length() > 7 )
    {
      debug(DEBUG_SUCCESS,response);
      state.setId(0); //TODO
      state.setSuccessfulScan(true);
      deviceHealthStateOutput.update(address,health,state);
      binaryOutput.valueChanged(true);
      return;
    }

    if ( response.length() == 1 )
    {
      if ( response.charAt(0) == 0x00 )
      {
        debug(DEBUG_FAILURE,response);
        if ( demoMode == 1 )
        {
          binaryOutput.valueChanged(false);
        }
        else
        {
          state.setSuccessfulScan(false);
          deviceHealthStateOutput.update(address,health,state);
        }
        return;
      }
      // This may be the left overs of a successful scan in a second message
      return;
    }

    // Unrecognised message. Log it and return
    logger.log(Level.WARNING, "Received unrecognised message ["+response+"]");
  }

  private void debug(int flag, String message)
  {
    if ( ( debugLevel & flag) > 0 )
    {
      logger.log(Level.INFO, HexHelper.toHexString(message).toString());
    }
  }

  /* ------------------------------------------------------------------------ */

  private class MyDebugConduit implements Debug
  {
    public void debugLevelChanged(int level)
    {
      debugLevel = level;
    }
  }

  private class EmulatorThread extends Thread
  {
    private boolean toggle = false;
    private SimpleAddress address = new SimpleAddress("Ekey");
    private DeviceHealth health = new SimpleDeviceHealth(DeviceHealth.USEFUL);
    private EkeyDeviceState state = new EkeyDeviceState(true);

    public void run()
    {
      if ( stopRunning )
      {
        logger.log(Level.INFO, "Emulator thread terminating");
        return;
      }
      state.setSuccessfulScan(toggle);
      toggle = ! toggle;
      state.setId(0);
      deviceHealthStateOutput.update(address,health,state);
      long delayMillis = System.currentTimeMillis() + 3000;
      threadManagerConduit.queue(this, delayMillis);
    }
  }
}